#写在前面

#介绍

这是一本关系计算机和操作系统的书，旨在通过在一步步从无到有构建一个操作系统的过程中，体会操作系统的结构、概念以及系统层的编程。

同时，本书也想通过细致的介绍，尽量做到让读者能够了解到操作系统和计算机系统中的每一个细节。

再开始之前，我们需要先了解一些关于编程语言的重要知识，同时还需要达到熟练的运用这些知识解决问题的水准。当然，有一些东西其实也就是嵌入式平台和系统级编程的时候会使用到的知识。

本书采用C语言和x86汇编语言。读者需要具备一定的C语言和x86汇编语言基础，同时还能灵活的使用这两门语言。

#C语言

我们假定读者已经具备了一定的C语言编程基础，这里就简单地阐述一些C语言在操作系统开发中的一些相当重要的东西。

##内核空间中的C语言

###16位和32位的C语言

在开始操作系统开发的时候，你肯定会不知所措。在计算机被唤醒的时候，CPU运行在16位的“实模式”下，这种模式下是无法运行32位的C编译器生成的程序的。也就是说，想要开发一个16位的操作系统，就必须得使用支持16位的C编译器。同样，如果想要开发一个32位的操作系统，就得使用32位的C编译器了。

本书中的操作系统是构建在32位的平台上的，因此，书中采用32位的C编译器。

###C语言和可执行文件

面对C语言的第一个问题就是，C语言无法直接通过编译得到一个平坦的二进制程序。平坦的二进制程序是指程序的入口（也就是main函数）始终在可执行文件的第一个字节开始。不对，我们关注这个问题有什么用？

这得从以前的DOS下的COM程序说起。DOS下的COM程序就是一个平坦的可执行文件，这种文件没有任何过多的附加信息，仅仅由程序的指令和一些程序内部需要使用到的数据组成。执行这样的程序的时候，只需要告诉CPU从这个文件的开头读取指令，一步步执行就可以了。这样执行一个程序就变的非常简单了，只要把整个文件加载到内存，从文件开头一步步往下执行就可以了。当我们的机器开机的时候，整个计算机是交给BIOS中的ROM里的程序控制着的，这时候它是不知道要运行什么程序的，也不知道怎么运行。所以呢，人们干脆把它设计成不需要关心程序文件的结构的BIOS，反正只需要从磁盘中的一个固定位置读取一个固定长度的程序，加载到内存里，然后从程序的最开始读取指令执行就行了。这个固定的位置就是引导扇区，那个固定的程序就被称为BootLoader，这个固定的长度就是512字节。

所以，从上面的描述来说，Bootloader是没办法用C语言来编写的，因为C语言编译器生成的可执行文件是有一定格式的，它没法生成这种平坦的可执行文件。没有选择，只能使用汇编语言来做这个第一阶段的程序。

###用C语言编写Bootloader

其实，Bootloader还是可以用C语言来编写的。方法也非常的多，比如我们可以将一个汇编语言编译出来的二进制程序和一个C编译后的的可执行文件拼接在一起，二进制部分的程序负责去识别和加载附加在它后面的那个C编译后的程序。

这只是一种可行的方法。很多Bootloader都用到了C语言，比如GRUB、微软的NTLDR和Boot Manager。由于我们选择了32位的C语言，我们也有办法能够将16位代码嵌入到32位的程序里面。

当然，这样做的话就太麻烦了，所以我们这里直接选用汇编语言来实现Bootloader。

###调用C语言编写的内核

当Bootloader准备好之后，它就得开始找到我们C语言编写的系统内核，并找到入口点来执行了。由于C语言生成的可执行文件具备一定的文件格式，因此我们必须得让Bootloader能够识别这种文件格式，找到内核的入口点，才能执行。具体如何实现，后续有关章节会详细说到。这样，我们就可以使用C语言来编写操作系统的内核了。

##指针

###介绍

读到此处，我么已经假定读者已经掌握了C语言指针的精髓。在系统软件中，指针无处不在。因此，能够熟练的使用C的指针变的相当重要。

指针就是一个变量，它保存了某个东西在内存中的地址。声明一个指针，只需要使用*即可。

```C
    char* pointer;
```

我们说指针中保存的是一个地址。但是，我么并没有给上面的指针明确要指向的地址，那它究竟指向何处呢？上述代码中的指针被称为“野指针”。野指针就是一个可能指向任何位置的指针。C语言的编译器是不会对变量做任何初始化工作的，因此上述指针会指向何处也不得而知的，哪里都有可能，比如指向某个变量，某段程序的代码，或者某个硬件的地址。

###物理地址空间

物理地址空间中定义了你能在程序中使用的所有地址。这些地址能够引用到物理地址空间中的所有内容。包括物理内存（RAM），硬件设备，或者什么也不是。这一点和普通的应用层编程很不一样（比如在Windows下），应用层编程中所有的地址都对应着内存。

比如在普通的应用层编程中，下面这段代码会产生段错误，并且直接导致程序崩溃：

```C
    char* pointer = 0;
    *pointer = 0;
```

这段程序中声明了一个指针，并让它指向地址编号为0的地方，这个地方是应用层的程序无法访问到的。因此，操作系统不允许应用程序对它写入任何数据。

不过，这种代码在后面涉及到的C语言编写的内核中是可以执行的，不会发生任何错误，它只是不小心修改了中断向量表中的第一个字节而已。

因此，这里对应用编程和系统编程的不同作出两点总结：

* 当你访问NULL这样的指针指向的位置时，程序不会崩溃
* 一个指针可以指向物理地址空间中的任意位置

如果在程序中向一个根本不存在的地址读取数据，程序什么也得不到。如果向一个根本不存在的地址写入数据，就相当于什么也没有做。当然，如果向这种地方写入数据之后马上读取，也得不到原来写入的数据，可以理解为写入的数据直接被丢掉了。

更有意思的是，ROM中的数据其实是被映射到了物理地址空间中的。也就是说，你可以通过指针来读取或者修改ROM中的数据。比如BIOS。由于ROM通常来说是只读的，向ROM中写入数据也就相当于什么也没做。不过，你可以去读取数据。

还有一些硬件设备的数据也被映射到物理地址空间中了的，具体的细节跟系统的配置有很大关系。也就是说，你在物理地址空间中的不同地方读写数据会的到不一样的结果，发生不一样的现象。

说了这么多，在系统编程中，指针不再是简单的指针了。在系统编程中，指针可能指向的是内存（RAM），也可能是某个硬件中的某个数据存储器，或者别的什么东西。

##动态内存分配

在应用层编程中，我们经常使用malloc()、free()和new、delete来从堆中分配和释放内存。但是在操作系统编程中就不一样了。分配内存，我们只需要这么做：

```C
    char* pointer = (char*)0x5000;
```

是不是很高端？这时候，一切都在自己的掌控之中，我们只需要直接用一个指针指向物理地址空间中的一个地方，然后自己心里默默的想着：“这里我分配了1KB的内存”就可以了。

其实，在这时候，根本没有什么动态内存分配。C和C++的动态内存分配是基于操作系统提供的环境下的，也就是说得现有一个操作系统才行。但是，我们不就正在做一个操作系统么。就是这样。我们得自己实现一套内存管理的机制来提供像malloc()和free()或者new和delete这样的东西。

目前的话，分配内存唯一的办法就是随便找一块没有使用的地方当作自己分配好的内存吧。

##内联汇编

有些时候，某些特殊的指令是无法直接通过C语言代码来完成的。这时候，我们需要使用汇编语言来完成这样的指令。

不过，大多数编译器都提供了一些方法，可以在C语言代码中混杂一些汇编代码，也就是内联汇编。比如在Microsoft Visual C++中，使用“_asm”就可以了：

```C
    _asm cli  ; 关闭中断
```

还可以直接写成块的汇编代码：

```C
    _asm {
        cli
        hlt
    }
```

##标准库和运行时库（RTL）

在OS编程环境下，我们只能使用一些不需要依赖操作系统就能运行的库。像printf()、scanf()都不能直接使用了。超过90%的库函数都需要操作系统的支持，所以，只能自己实现这些功能了。

运行时库（RTL）就是一套程序在运行的时候所依赖的服务。所以，RTL也需要建立在操作系统的基础之上。所以，还得自己实现RTL。

在使用C++的时候就需要RTL来提供构造函数和析构函数的功能。如果想在OS编程中使用C++，就必须得自己实现一套RTL。本书中也会自己实现一套RTL来支持C和C++的基本功能。

##错误排查

###调试

因为目前没有printf()这样的函数，如果写代码的时候出问题了怎么办？本书将会介绍如何使用Bochs模拟器提供的调试功能。它不仅可以用来模拟运行自己的操作系统，还能用来进行调试。

##结束

接下来，我们将开始深入探讨操作系统到底为何物，同时书中还会介绍一些相当好用的工具。

http://www.brokenthorn.com/Resources/OSDev0.html
