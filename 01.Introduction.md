#自己动手开发操作系统：导论
[原文地址](http://www.brokenthorn.com/Resources/OSDev1.html)

本系列的写作目的是展示并教导从零开始的操作系统开发。
##这是什么？
操作系统是一个非常复杂的课题，因此学习系统是如何工作的会让你感觉非常棒。这个系列的目的就是从零开始指导有关开发操作系统的"黑科技"。无论你是想做你自己的操作系统，还是想学习它们的工作原理，这个系列就是为你而生的！

##操作系统是什么？
操作系统提供了基本的功能以及交互和体验。它的基本目的是创建一个可的操作环境。
`Windows`， `Linux` 和 `Macintosh` 就是操作系统。

##如果你从来没编过程的话...
计算机编程就是设计和编写计算机可以加载和执行的软件或程序。操作系统就是用来提供这个环境的。
操作系统可不是一个程序，而是一系列可以完成相应工作和通信的软件集合。这也就是我们所说的"操作环境"。
因为操作系统就是一系列的软件，所以为了开发一个操作系统，我们必须要知道如何编写软件。也就是说，我们必须懂得编程。
如果你之前从未编过程的话，来看看以下的"所需要的知识"小节。它包含了很多不错的 `C++` 与 `80x86 汇编`的指导书和教程。

##所需要的知识
###`C` 语言的知识
对一门高级语言的掌握，例如说 `C` ，会让操作系统开发变的更加容易。其中最常用的语言包括 `C`, `C++` 和 `Perl` 。并不是必须要使用这些才能开发，其他语言也是可以的。我甚至见过使用 `FreeBASIC` 来写操作系统的！不过，使用更高级更抽象的编程语言来开发的话会使得运行和维护变得困难。

最常见的是`C` 和 `C++`，而其中 `C` 的应用最广:它作为一个"中级"语言，不仅提供了高级的结构还提供了接近汇编语言的底层操作以供我们使用，因此与操作系统的联系更加紧密。正因为如此，使用 `C` 来开发比较简单，这也是它被广泛使用的主要原因。 事实上，`C` 最初就是为系统级的开发和嵌入式设计的！
所以我们将在开发操作系统的大部分时间里使用 `C`。
`C` 是一门比较复杂的编程语言，但我们可以通过看本书来得一个大体上的认知。如果你不了解 `C` 的话，向你推荐以下的书目：
* *Learn C - A complete resource for a beginner*
* *Cprogramming.com*
* *Thinking in C++*
我个人看的是最早的 *The C++ Programming Language*，但这本书已经比较过时了。

###`x86` 汇编的知识
`80x86` 汇编是一种底层编程语言。汇编语言有着与处理器指令一一对应的映射，所以很适合于硬件有关的编程。
但因为汇编语言非常底层，所以它比高级语言更复杂更难用。所以为了简化开发流程和复杂度，我们只在必要的时候使用汇编。
汇编语言是另一门需要通过系统地学习才能掌握的语言。所以如果你不了解汇编的话，那么这个书单可能很适合你：
* *Assembly Language: Step by Step*
* *Art of Assembly*
我是通过 *Assembly Language: Step by Step* （一本非常好的入门书）和 *Art of Assembly* 来学习汇编的。它们可都是非常好的书。

###Let‘s Go!
我们刚刚所说的就是所有你需要掌握的知识，其他的就在开发的时候再细说吧。预先**警告**：从这里开始，我将不会解释 `C` 或者汇编语言中的概念。但我仍然会解释你还不熟悉的，比如 `lgdt` , `sti`, `cli`, `but` 以及`cpuid` 。


##工具
在编写一些底层代码时，我们需要专门的底层工具来协助开发。虽然它们不是必需的，但因为它们非常有用，我们还是向你高度推荐!

### `NASM` - 汇编器
`Netwide` 汇编器（`NASM`）能产生 16 位纯二进制程序，而这是大多数其他的汇编器（如 `Turbo` 汇编器 `TASM`，微软宏汇编器 `MASM`）做不到的。

在操作系统的开发中，一些程序必须是纯二进制可执行文件。为此， `NASM` 是一个很好的选择。

我们可以通过这个[链接](http://nasm.sourceforge.net/)下载 `NASM` 。

### 微软 `Visual C++` 2005 或 `Visual C++` 2008

因为我们很关心可移植性，所以我们的大多数代码是`C`语言写成的。

因为一些特性不一定是所有的编译器都支持的，所以开发时我们要限制它们的使用。比如，我们不能用运行时相关的特性（模版、异常）或者老旧（但好用）的标准库。取决于你的设计，你可能需要支持或改变你的操作系统的某些特性，比如在一个特定的地址进行加载，或在二进制程序里添加内部段等。所以我们认为并不是所有的编译器都有能力编译操作系统代码。

我将使用微软 `Visual C++` 来进行开发。不过，其他的编译器如 `DJGPP` ， `GCC` 甚至 `Cygwin` 也都是可以的。（`Cygwin` 是一个用来模拟 `Linux` 命令解释器的程序，所以 `Cygwin` 中有调用 `GCC` 的接口。）

你能从[这里](http://www.microsoft.com/express/download/)下载 `Visual C++ 2008`

你仍可以[这里](http://www.microsoft.com/downloads/details.aspx?FamilyID=32BC1BEE-A3F9-4C13-9C99-220B62A191EE&displaylang=en)下载 `Visual C++ 2005`

### 对其他编译器的支持

正如之前所说，我们可以使用一些其他的编译器来编译操作系统。尽管这里主要使用的编译器是 `Visual C
++`，我仍会解释如何一步步配置环境来用你所喜欢的那个。

我将叙述如何为以下的编译器配置环境：

* `DJGPP`
* 微软 `Visual C++ 2005`
* `GCC`

如果可能，我将在以后试着支持以下的编译器：
* `Mingw`
* `Pelles C`

如果你想让我支持别的编译器的话请联系我。


###覆写 `Boot Loader`的工具###

`Bootloader` 是一个储存在盘片上一个 512 Byte 扇区上的纯二进制程序。操作系没有它就不能工作，所以这是它非常重要。`Boot Loader`在计算机启动时作为操作系统一部分被 `BIOS` 加载并被处理器执行。

我们可以用 `NASM` 来“编译”这个程序，但我们如何把它写在软盘上呢？我们可不能直接复制过去哟！事实上，在格式化软盘后我们必须用自己编写的 `bootloader` 来覆写 `Windows` 系统放在其上的引导记录。要记住，当 `BIOS` 查找可引导磁盘时候只检查引导扇区。 引导记录放在引导扇区上！所以我们必须覆写引导记录。

有很多种方法可以覆些这个扇区。这里我们将接触两种。如果`Plan A`在你的系统上不起作用，你可以试试另一个嘛。

**警告：在我解释完如何使用之前，不要试图去这么干！不正确使用会毁掉你硬盘上的数据或让你的 PC 无法启动。**

####`PartCopy` - 底层拷贝器####
`PartCopy` 允许在两个设备间进行扇区级别的拷贝。`PartCopy` 代表 "Partial copy"。它的功能是从一个特定的地址拷贝一些扇区到另一个地址。
你可以从[这里](http://www.brokenthorn.com/Resources/Programs/pcopy02.zip)下载它。

####Windows Debug 命令####
windows 提供了一个在命令行下的调试器。我们能用这个软件做许多事，但这里我们只需要哟用它拷贝我们的 bootloader 到盘片的的第一个扇区。
打开命令提示符，输入`debug`.一个小的提示符将会向你打招呼(-):
```
C:\Documents and Settings\Michael>debug
-
```
这就是你输入命令的地方。`h`是帮助命令，`q`是退出命令。`w`是写命令，也是对我们最重要的。
你可以让调试器加载一个文件进内存，比如，我们的 bootloader：
```
C:\Documents and Settings\Michael>debug boot_loader.bin
-
```
它允许我们在上面进行操作。（我们可以使用`L(Load)`命令来加载的文件。在上面的例子里，boot_loader.bin 将被加载到地址 0x100.为了在第一个扇区写入文件，我们需要用`W(Write)`命令的以下格式：
```
W [address] [drive] [firstsector] [number]
```
好吧，让我们来解释下：文件在地址 0x100.我们想写在软驱上（Drive 0）上。软盘的第一个扇区是0号扇区，它的扇区总数是……1.
总的来说，这就是我们将 boot_loader.bin 写到软盘的启动扇区的命令：
```
C:\Documents and Settings\Michael>debug boot_loader.bin
-w 100 0 0 1
-q
```
如果你想学习关于这些命令的更多知识，看看这个[指导](http://mirror.href.com/thestarman/asm/debug/debug.htm)吧。

###VFD - 虚拟软驱###
不管你有没有软驱，这个程序都非常有用。他能用一个软盘镜像来模拟一个软驱，甚至镜像在内存里都可以。这个程序创建一个虚拟软盘镜像，允许你直接用资源管理器来格式化并在其上储存文件（比如，你的内核）。

###bochs 模拟器 - PC模拟器和调试器###
你在电脑里插入一张软盘，希望它能工作。你重启你的电脑，热切地看着你伟大的创造。……直到你的的软驱挂掉，因为你忘记向控制器里写入命令了。
当写低级代码时，如果你不小心，很可能会毁掉你的硬件。并且，为了测试你的操作系统，在开发过程中你需要重启电脑数百次。
并且，万一你的电脑只是重启怎么办？万一你的内核崩溃怎么办？因为你的操作系统没有调试器，事实上是不可能进行调试的。
解决办法？一个 PC 模拟器。模拟器有许多种，比如 VMWare 或者 Bochs 。我将使用 Bochs 和微软 Virutal PC 来进行测试。
你可以在[这里](http://bochs.sourceforge.net/)下载 Bochs

###这就是了###
你不需要知道如何使用我列出的软件。当我们开始用时我将解释如何使用。
如果你想在一个没有软驱的电脑上使用的你的系统，一个在 CD 中的软盘镜像也是可以的。这可以用支持软盘模拟的 BIOS 上做到。
找到一个能从软盘镜像中创建一个可启动 ISO 的 CD 烧录软件（我个人使用 MagicISO ）是很简单的。然后，简单地在 CD 上烧录 ISO 镜像然后能用了。

##生成过程##
以上列出了许多工具。为了更好地明白它们的作用，我们应该看一下整个操作系统的开发过程。
* 准备
  1. 使用 VFD 来创建并格式化一个虚拟的软盘镜像来使用
  2. 配置 Bochs 模拟器来从镜像启动
* Bootloader
  1. 用 NASM 在 bootloader 处创建纯二进制程序
  2. 使用 PartCopy 或者 DEBUG 命令来用我们的 bootloader 覆写软盘镜像原来的 Bootloader
* 内核（以及其他的程序）
  1. 把所有的源文件汇编和/或编译成一个能被在bootloader 上加载和执行的目标文件（如 ELF 或者 PE）
  2. 使用 windows explorer 来将内核复制到软盘上
* 测试！
  1. 使用 bochs 模拟器和 debugger，或使用一个真正的软盘，再或者使用 MagicISO 来创建一个可启动的 CD。

##下次见!##
这里列出来的一些术语和概念你可能很陌生。不要担心-- 在接下来的文章中我们会解释一切的！
本文的目的是为以后的文章建立一个垫脚石。本文提供了一个基础的介绍以及我们将要使用的一系列工具。当我们需要的时候我将解释如何使用他们，所以除了“所要求的知识”列出的书目外你不需要额外学习其他知识。
我们也对操作系统的构建有了大概的认识。总的来说，这个过程的表述十分简略，但给了我们一个上述程序在什么时候发挥作用了解。
在下一个章节中我们将回到第一个硬盘操作系统（DOS）的时代并漫步历史。我们也将学习一些操作系统的基本概念。
我们不打算杂在现在使用上述软件，所以你不必现在就下载它们。
